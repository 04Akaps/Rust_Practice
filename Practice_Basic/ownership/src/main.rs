fn s() {
    // s는 아직 유효하지 않습니다. => 선언 전

    let s = "hello"; // s는 이제 유효합니다.
}
// 함수 밖이므로 s 유효하지 않습니다.

fn main() {
    let mut s = String::from("hello");

    s.push_str(", world!"); // push_str()은 해당 스트링 리터럴을 스트링에 붙여줍니다.

    println!("{}", s); // 이 부분이 `hello, world!`를 출력할 겁니다.
}

fn copy() {
    let mut s = String::from("hello");
    let s2 = s;

    // println!("{}", s); // 이 부분이 `hello, world!`를 출력할

    // 만약 복사를 하고자 한다면 다음과 같이 활용합니다.

    // let s3 = s.clone();
}

/*

러스트의 소유권 규칙은 총 3가지가 있습니다.

1. 각각의 값은 해당값의 오너라고 불리는 변수가 있다.
2. 한번에 딱 하나의 오너만 존재 가능하다.
3. 오너가 스코프 밖으로 벗어날때 버려진다.

무슨소리냐면 위에 있는 s변수와 같습니다.

Rust는 데이터 구조가 두가지가 있습니다.
- 힙, 스택

일반적인 변수 선언은 스택의 데이터 메모리에 들어가지만, string같은 경우에는 조금 다릅니다.
- 물론 일반적인 string선언도 스택으로 들어갑니다.

힙에 저장되는 데이터는 가비지 컬렉터에 의해서 관리가 됩니다.
- 즉 함수 실행이 긑나면 메모리가 반납됩니다.

copy함수를 살펴보면 힙에 저장된 데이터는 조금 다르게 동작을 합니다.

일반적으로 변수가 선언되면 메모리가 할당이 되고 해당 메모리에 값이 저장이 되게 됩니다.

같은 메모리를 가지고 있게 됩니다.
- 즉 S2가 바뀌면 s가 바뀝니다.
- 이게 얕은복사, 깊은 복사 이야기 입니다.

rust에서는 좀 신기하게 접근응ㄹ 하였습니다.

이렇게 같은 메모리를 가지게 되고 메모리를 비워줘야 할떄 두 변수 모두 같은 메모리이기 떄문에 메모리 충돌이 일어나게 되는데

rust는 이 문제를 해결하기 위해서기존에 복사하는 주체 s를 그냥 삭제해 버립니다.
*/